<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust WASM SVG Line Editor</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    :root {
      --ink: #0f172a;
      --paper: #f5f6fb;
      --accent: #2dd4bf;
      --accent-dark: #0ea5e9;
    }
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: var(--paper);
      color: var(--ink);
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      gap: 10px;
      flex-wrap: wrap;
    }
    h1 { margin: 0; font-size: 24px; }
    button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover { background: var(--accent-dark); }
    button.active {
      background: #ef4444;
    }
    input[type="color"] {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    svg {
      border: 1px solid #ddd;
      background: white;
      border-radius: 4px;
      display: block;
      margin-bottom: 20px;
      touch-action: none;
    }
    #lines line {
      stroke: var(--ink);
      stroke-width: 2;
      stroke-linecap: round;
    }
    #preview {
      stroke: var(--accent);
      stroke-width: 2;
      stroke-dasharray: 5,5;
      opacity: 0.6;
      display: none;
    }
    #preview.active { display: block; }
    #fills polygon {
      stroke: none;
      opacity: 0.7;
    }
    #debugLayer {
      pointer-events: none;
    }
    #debugNearestLine {
      stroke: #0ea5e9;
      stroke-width: 3;
      stroke-dasharray: 3,3;
      display: none;
    }
    #debugNearestLine.active { display: block; }
    #debugNearestPoint {
      fill: #0ea5e9;
      r: 4;
      display: none;
    }
    #debugNearestPoint.active { display: block; }
    #debugRay {
      stroke: #0ea5e9;
      stroke-width: 1;
      opacity: 0.5;
      display: none;
    }
    #debugRay.active { display: block; }
    #debugIntersections circle {
      fill: #ef4444;
      r: 3;
    }
    #fillDebugLayer {
      pointer-events: none;
    }
    #fillDebugLayer polygon {
      stroke-width: 2;
      fill-opacity: 0.2;
    }
    #fillDebugLayer .candidate-ab {
      stroke: #9333ea;
      fill: #9333ea;
    }
    #fillDebugLayer .candidate-ba {
      stroke: #f97316;
      fill: #f97316;
    }
    #fillDebugLayer .selected-fill {
      stroke: #22c55e;
      stroke-width: 3;
      fill: none;
    }
    #status {
      font-size: 12px;
      color: #666;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Rustroke</h1>
      <div style="display: flex; gap: 10px;">
        <button id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
        <button id="clearBtn" title="Clear">Clear</button>
        <button id="fillBtn" title="Fill Region">Fill</button>
        <input id="fillColor" type="color" value="#747474" title="Fill color">
        <button id="debugBtn" title="Toggle Debug Mode">Debug</button>
        <button id="graphDebugBtn" title="Toggle Graph Debug">Graph Debug</button>
        <button id="toggleLinesBtn" title="Toggle Lines Visibility">Hide Lines</button>
      </div>
    </header>

    <svg id="canvas" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
      <defs>
        <style>
          text { font-size: 12px; fill: #999; }
        </style>
      </defs>
      <g id="fills"></g>
      <g id="lines"></g>
      <g id="graphDebugLayer" pointer-events="none"></g>
      <line id="preview"></line>
      <g id="debugLayer">
        <line id="debugNearestLine"></line>
        <circle id="debugNearestPoint"></circle>
        <line id="debugRay"></line>
        <g id="debugIntersections"></g>
        <g id="fillTraceLayer" pointer-events="none"></g>
        <g id="fillDebugLayer"></g>
      </g>
    </svg>

    <div id="status">Lines: 0</div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const linesGroup = document.getElementById('lines');
    const fillsGroup = document.getElementById('fills');
    const preview = document.getElementById('preview');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const fillBtn = document.getElementById('fillBtn');
    const fillColor = document.getElementById('fillColor');
    const debugBtn = document.getElementById('debugBtn');
    const graphDebugBtn = document.getElementById('graphDebugBtn');
    const toggleLinesBtn = document.getElementById('toggleLinesBtn');
    const statusEl = document.getElementById('status');
    const debugLayer = document.getElementById('debugLayer');
    const debugNearestLine = document.getElementById('debugNearestLine');
    const debugNearestPoint = document.getElementById('debugNearestPoint');
    const debugRay = document.getElementById('debugRay');
    const debugIntersectionsGroup = document.getElementById('debugIntersections');
    const fillTraceLayer = document.getElementById('fillTraceLayer');
    const graphDebugLayer = document.getElementById('graphDebugLayer');
    const fillDebugLayer = document.getElementById('fillDebugLayer');
    const viewBox = canvas.viewBox.baseVal;

    let wasm = null;
    let dragging = false;
    let fillMode = false;
    let debugMode = false;
    let graphDebugMode = false;
    let showLines = true;
    /** @type {{x: number, y: number}} */
    let startPoint = { x: 0, y: 0 };

    /**
     * Convert pointer event coordinates to SVG viewBox coordinates
     * @param {PointerEvent} evt - pointer event
     * @returns {{x: number, y: number}} point in SVG coordinates
     */
    function toSvgPoint(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = ((evt.clientX - rect.left) / rect.width) * viewBox.width + viewBox.x;
      const y = ((evt.clientY - rect.top) / rect.height) * viewBox.height + viewBox.y;
      return { x, y };
    }

    /**
     * Render lines and fills from WASM memory
     */
    function renderFromWasm() {
      if (!wasm) return;
      const len = wasm.editor_export_len_f32();
      const ptr = wasm.editor_export_ptr_f32();
      
      // Only render lines if showLines is true
      if (showLines) {
        if (!ptr || len === 0) {
          linesGroup.replaceChildren();
          statusEl.textContent = 'Lines: 0';
        } else {
          const arr = new Float32Array(wasm.memory.buffer, ptr, len);
          const fragments = [];
          for (let i = 0; i < arr.length; i += 4) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', arr[i + 0]);
            line.setAttribute('y1', arr[i + 1]);
            line.setAttribute('x2', arr[i + 2]);
            line.setAttribute('y2', arr[i + 3]);
            fragments.push(line);
          }
          linesGroup.replaceChildren(...fragments);
          statusEl.textContent = `Lines: ${wasm.editor_line_count()}`;
        }
      } else {
        // Hide lines but still update status
        linesGroup.replaceChildren();
        if (ptr && len > 0) {
          statusEl.textContent = `Lines: ${wasm.editor_line_count()} (hidden)`;
        } else {
          statusEl.textContent = 'Lines: 0';
        }
      }

      // Render fills
      const fillsLen = wasm.editor_export_fills_len();
      const fillsPtr = wasm.editor_export_fills_ptr();
      if (fillsPtr && fillsLen > 0) {
        const fillsArr = new Float32Array(wasm.memory.buffer, fillsPtr, fillsLen);
        const fillFragments = [];
        let i = 0;
        while (i < fillsArr.length) {
          const pointCount = fillsArr[i];
          const r = Math.round(fillsArr[i + 1] * 255);
          const g = Math.round(fillsArr[i + 2] * 255);
          const b = Math.round(fillsArr[i + 3] * 255);
          const a = fillsArr[i + 4];
          i += 5;

          const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          let points = '';
          for (let j = 0; j < pointCount && i < fillsArr.length; j++) {
            const x = fillsArr[i];
            const y = fillsArr[i + 1];
            points += `${x},${y} `;
            i += 2;
          }
          polygon.setAttribute('points', points);
          polygon.setAttribute('fill', `rgba(${r},${g},${b},${a})`);
          fillFragments.push(polygon);
        }
        fillsGroup.replaceChildren(...fillFragments);
      } else {
        fillsGroup.replaceChildren();
      }

      // Update intersection dots if debug is on
      if (debugMode) {
        updateDebugIntersections();
      }

      if (graphDebugMode) {
        renderGraphDebug();
      } else {
        graphDebugLayer.replaceChildren();
      }
    }

    /**
     * Update debug intersection dots from cached intersections in Rust
     */
    function updateDebugIntersections() {
      const intLen = wasm.editor_intersections_len_f32();
      const intPtr = wasm.editor_intersections_ptr_f32();
      debugIntersectionsGroup.replaceChildren();

      if (intLen <= 0) return;

      const intArr = new Float32Array(wasm.memory.buffer, intPtr, intLen);
      const count = intArr[0];

      for (let i = 0; i < count; i++) {
        const x = intArr[1 + i * 2];
        const y = intArr[1 + i * 2 + 1];
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', 3);
        circle.setAttribute('fill', '#ef4444');
        debugIntersectionsGroup.appendChild(circle);
      }
    }

    /**
     * Render fill debug diagnostics (both candidate polygons)
     */
    function renderFillDebug() {
      // Only render fill debug visuals in debug mode
      if (!debugMode) {
        fillDebugLayer.replaceChildren();
        return;
      }
      
      fillDebugLayer.replaceChildren();
      
      if (!wasm) return;
      
      // Get fill walk debug data
      const len = wasm.editor_fill_walk_debug_len_f32();
      const ptr = wasm.editor_fill_walk_debug_ptr_f32();
      
      if (len < 12 || !ptr) {
        return;
      }
      
      const arr = new Float32Array(wasm.memory.buffer, ptr, len);
      
      // Parse diagnostic data for up to 2 candidates (12 floats each)
      const candidates = [];
      let idx = 0;
      while (idx + 12 <= len) {
        const direction = Math.floor(arr[idx]);
        const pointCount = Math.floor(arr[idx + 1]);
        const signedArea = arr[idx + 2];
        const area = arr[idx + 3];
        const inside = arr[idx + 4] > 0.5;
        const distSq = arr[idx + 5];
        const dist = arr[idx + 6];
        const isSimple = arr[idx + 7] > 0.5;
        const minx = arr[idx + 8];
        const miny = arr[idx + 9];
        const maxx = arr[idx + 10];
        const maxy = arr[idx + 11];
        
        candidates.push({direction, pointCount, area, inside, dist, isSimple});
        idx += 12;
      }
      
      // Log to console
      if (candidates.length > 0) {
        console.log('[Fill Debug] Candidate AB:', candidates[0]);
        if (candidates.length > 1) {
          console.log('[Fill Debug] Candidate BA:', candidates[1]);
        }
      }
    }

    /**
     * Render fill trace from WASM buffer
     */
     function renderFillTrace() {
      // Only render fill trace visuals in debug mode
      if (!debugMode) {
        fillTraceLayer.replaceChildren();
        return;
      }
      
      fillTraceLayer.replaceChildren();

      if (!wasm) return;

      const len = wasm.editor_fill_trace_len_f32();
      const ptr = wasm.editor_fill_trace_ptr_f32();

      if (len <= 1 || !ptr) {
        console.log('[Fill Trace] No trace data');
        return;
      }

      const arr = new Float32Array(wasm.memory.buffer, ptr, len);
      const pointCount = Math.floor(arr[0]);

      if (pointCount <= 0) {
        console.log('[Fill Trace] No trace points');
        return;
      }

      const stepTypeNames = ['ORIGIN', 'NEAREST', 'ENDPOINT', 'CHAIN', '?', '?', '?', '?', '?', 'CLOSED'];
      const stepTypeColors = {
        0: '#ff8c00',  // orange
        1: '#00bfff',  // cyan
        2: '#ff1493',  // magenta
        3: '#00ff00',  // green (default for chain)
        9: '#ff0000'   // red
      };

      console.log(`%c[Fill Trace] Found ${pointCount} steps`, 'color: #2563eb; font-weight: bold; font-size: 12px');

      let idx = 1;
      for (let i = 0; i < pointCount && idx < arr.length; i++) {
        const x = arr[idx];
        const y = arr[idx + 1];
        const stepType = Math.floor(arr[idx + 2]);
        idx += 3;

        const stepName = stepTypeNames[stepType] || 'UNKNOWN';
        const stepColor = stepTypeColors[stepType] || '#999999';

        // Log to console
        let logMessage = `  Step ${i}: `;
        if (stepType === 0) {
          logMessage += `ORIGIN at (${x.toFixed(0)}, ${y.toFixed(0)})`;
        } else if (stepType === 1) {
          logMessage += `NEAREST point on segment at (${x.toFixed(0)}, ${y.toFixed(0)})`;
        } else if (stepType === 2) {
          logMessage += `ENDPOINT (start of chain) at (${x.toFixed(0)}, ${y.toFixed(0)})`;
        } else if (stepType === 3) {
          logMessage += `CHAIN point #${i - 2} at (${x.toFixed(0)}, ${y.toFixed(0)})`;
        } else if (stepType === 9) {
          logMessage += `CLOSED/CYCLE at (${x.toFixed(0)}, ${y.toFixed(0)}) ✓`;
        }

        console.log(`%c${logMessage}`, `color: ${stepColor}; font-weight: ${stepType === 0 || stepType === 1 || stepType === 2 ? 'bold' : 'normal'}`);

        // Render circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('fill', 'none');
        circle.setAttribute('stroke-width', 2);

        if (stepType === 0) {
          circle.setAttribute('stroke', '#ff8c00');  // orange
          circle.setAttribute('r', 5);
        } else if (stepType === 1) {
          circle.setAttribute('stroke', '#00bfff');  // cyan
          circle.setAttribute('r', 5);
        } else if (stepType === 2) {
          circle.setAttribute('stroke', '#ff1493');  // magenta
          circle.setAttribute('r', 5);
        } else if (stepType === 3) {
          // Alternate green/yellow
          const isGreen = (i - 2) % 2 === 0;
          circle.setAttribute('stroke', isGreen ? '#00ff00' : '#ffff00');
          circle.setAttribute('r', 4);
        } else if (stepType === 9) {
          circle.setAttribute('stroke', '#ff0000');  // red (closed)
          circle.setAttribute('r', 6);
        }

        fillTraceLayer.appendChild(circle);
      }

      console.log(`%c[Fill Trace] Complete`, 'color: #059669; font-weight: bold; font-size: 12px');
      
      // Log fill walk debug details
      logFillWalkDebug();
      // Log raw outgoing half-edges for the current node
      logNodeOutgoing();
      // Log duplicate node keys if any
      logNodeAudit();
      
      // Log adjacency debug (CCW half-edge walk info)
      logAdjacencyDebug();
    }

    function logAdjacencyDebug() {
      if (!wasm) return;
      
      if (typeof wasm.editor_adjacency_debug_len_f32 !== 'function' || 
          typeof wasm.editor_adjacency_debug_ptr_f32 !== 'function') {
        return;
      }
      
      const len = wasm.editor_adjacency_debug_len_f32();
      const ptr = wasm.editor_adjacency_debug_ptr_f32();
      
      if (len <= 5 || !ptr) {
        return;
      }
      
      const arr = new Float32Array(wasm.memory.buffer, ptr, len);
      const numEdges = Math.floor(arr[0]);
      
      if (numEdges <= 0) {
        return;
      }
      
      // Buffer format: [num_edges, cur.x, cur.y, prev.x, prev.y, (repeated) from.x, from.y, to.x, to.y, seg_id, he_idx]
      const curX = arr[1];
      const curY = arr[2];
      const prevX = arr[3];
      const prevY = arr[4];
      
      console.log(`%c[Adjacency] Junction (${curX.toFixed(0)}, ${curY.toFixed(0)}) - ${numEdges} outgoing edge(s)`, 
                  'color: #d946a6; font-weight: bold; font-size: 11px');
      
      let idx = 5;
      for (let i = 0; i < numEdges && idx + 5 < len; i++) {
        const fromX = arr[idx];
        const fromY = arr[idx + 1];
        const toX = arr[idx + 2];
        const toY = arr[idx + 3];
        const segId = Math.floor(arr[idx + 4]);
        const heIdx = Math.floor(arr[idx + 5]);
        idx += 6;
        
        const isReverse = toX === prevX && toY === prevY;
        const style = isReverse ? 'color: #ef4444; text-decoration: underline;' : 'color: #06b6d4;';
        
        console.log(
          `%c  Edge ${i}: (${fromX.toFixed(0)}, ${fromY.toFixed(0)}) → (${toX.toFixed(0)}, ${toY.toFixed(0)}) | seg=${segId}, he=${heIdx}${isReverse ? ' [REVERSE]' : ''}`,
          style
        );
      }
    }

    function logFillWalkDebug() {
      if (!wasm) return;
      
      if (typeof wasm.editor_fill_walk_debug_len_f32 !== 'function' ||
          typeof wasm.editor_fill_walk_debug_ptr_f32 !== 'function') {
        console.warn('[FillWalk] Functions not available');
        return;
      }
      
      const len = wasm.editor_fill_walk_debug_len_f32();
      const ptr = wasm.editor_fill_walk_debug_ptr_f32();
      
      if (len <= 0 || !ptr) {
        return;
      }
      
      const arr = new Float32Array(wasm.memory.buffer, ptr, len);
      let idx = 0;
      let block = 0;

      while (idx + 6 < len) {
        const stepIndex = Math.floor(arr[idx]);
        const curX = arr[idx + 1];
        const curY = arr[idx + 2];
        const prevX = arr[idx + 3];
        const prevY = arr[idx + 4];
        const curDeg = Math.floor(arr[idx + 5]);
        const candCount = Math.floor(arr[idx + 6]);
        idx += 7;

        console.log(`%c[Step ${stepIndex}] Node (${curX.toFixed(1)}, ${curY.toFixed(1)}) deg=${curDeg} from (${prevX.toFixed(1)}, ${prevY.toFixed(1)}) | ${candCount} cand(s)`, 
                    'color: #9333ea; font-weight: bold; font-size: 11px');

        for (let i = 0; i < candCount && idx + 5 < len; i++) {
          const nextX = arr[idx];
          const nextY = arr[idx + 1];
          const nextDeg = Math.floor(arr[idx + 2]);
          const isDead = Math.floor(arr[idx + 3]) === 1;
          const angle = arr[idx + 4];
          const chosen = Math.floor(arr[idx + 5]) === 1;
          idx += 6;

          const symbol = chosen ? '✓' : ' ';
          const style = chosen
            ? 'color: #22c55e; font-weight: bold;'
            : (isDead ? 'color: #ef4444;' : 'color: #6b7280;');

          console.log(
            `%c  [${symbol}] -> (${nextX.toFixed(1)}, ${nextY.toFixed(1)}) deg=${nextDeg} dead=${isDead ? 1 : 0} angle=${angle.toFixed(3)}`,
            style
          );
        }

        block += 1;
      }

      if (block === 0) {
        console.log('[FillWalk] Buffer empty');
      }
    }

    function logNodeOutgoing() {
      if (!wasm ||
          typeof wasm.editor_node_outgoing_len_f32 !== 'function' ||
          typeof wasm.editor_node_outgoing_ptr_f32 !== 'function') {
        return;
      }

      const len = wasm.editor_node_outgoing_len_f32();
      const ptr = wasm.editor_node_outgoing_ptr_f32();
      if (!ptr || len < 8) {
        return;
      }

      const arr = new Float32Array(wasm.memory.buffer, ptr, len);
      const curId = Math.floor(arr[0]);
      const prevId = Math.floor(arr[1]);
      const curX = arr[2];
      const curY = arr[3];
      const prevX = arr[4];
      const prevY = arr[5];
      const outgoingCount = Math.floor(arr[6]);
      const candidateCount = Math.floor(arr[7]);

      console.log(`%c[Outgoing] Node ${curId} at (${curX.toFixed(0)}, ${curY.toFixed(0)}) from prev ${prevId} (${prevX.toFixed(0)}, ${prevY.toFixed(0)}) | outgoing=${outgoingCount} | candidates=${candidateCount}`,
                  'color: #0ea5e9; font-weight: bold; font-size: 11px');

      let idx = 8;
      for (let i = 0; i < outgoingCount && idx + 8 < len; i++) {
        const heIdx = Math.floor(arr[idx]);
        const fromId = Math.floor(arr[idx + 1]);
        const toId = Math.floor(arr[idx + 2]);
        const fromX = arr[idx + 3];
        const fromY = arr[idx + 4];
        const toX = arr[idx + 5];
        const toY = arr[idx + 6];
        const angle = arr[idx + 7];
        const isBack = Math.floor(arr[idx + 8]) === 1;
        idx += 9;

        const style = isBack ? 'color: #ef4444;' : 'color: #10b981;';
        console.log(
          `%c  he=${heIdx} ${fromId}->${toId}  (${fromX.toFixed(0)},${fromY.toFixed(0)}) → (${toX.toFixed(0)},${toY.toFixed(0)}) | angle=${angle.toFixed(2)} ${isBack ? '[BACK]' : ''}`,
          style
        );
      }
    }

    function logNodeAudit() {
      if (!wasm ||
          typeof wasm.editor_node_audit_len_f32 !== 'function' ||
          typeof wasm.editor_node_audit_ptr_f32 !== 'function') {
        return;
      }

      const len = wasm.editor_node_audit_len_f32();
      const ptr = wasm.editor_node_audit_ptr_f32();
      if (!ptr || len < 1) {
        return;
      }

      const arr = new Float32Array(wasm.memory.buffer, ptr, len);
      const groupCount = Math.floor(arr[0]);
      if (groupCount <= 0) {
        return;
      }

      console.log(`%c[NodeAudit] Found ${groupCount} duplicate key group(s)`, 'color: #f97316; font-weight: bold; font-size: 11px');
      let idx = 1;
      for (let g = 0; g < groupCount && idx + 2 < len; g++) {
        const kx = arr[idx]; const ky = arr[idx + 1]; const cnt = Math.floor(arr[idx + 2]); idx += 3;
        const pts = [];
        for (let i = 0; i < cnt && idx + 2 < len; i++) {
          const id = Math.floor(arr[idx]); const x = arr[idx + 1]; const y = arr[idx + 2];
          pts.push(`#${id} (${x.toFixed(2)}, ${y.toFixed(2)})`);
          idx += 3;
        }
        console.log(`  key=(${kx},${ky}) count=${cnt}: ${pts.join(' | ')}`);
      }
    }

    function renderGraphDebug() {
      if (!wasm || !graphDebugMode) {
        graphDebugLayer.replaceChildren();
        return;
      }

      if (typeof wasm.editor_export_graph_debug_len_f32 !== 'function' ||
          typeof wasm.editor_export_graph_debug_ptr_f32 !== 'function') {
        console.warn('[GraphDebug] Functions not available');
        return;
      }

      const len = wasm.editor_export_graph_debug_len_f32();
      const ptr = wasm.editor_export_graph_debug_ptr_f32();
      if (!ptr || len < 1) {
        graphDebugLayer.replaceChildren();
        return;
      }

      const arr = new Float32Array(wasm.memory.buffer, ptr, len);
      let idx = 0;
      const segCount = Math.floor(arr[idx++] || 0);
      const segFragments = [];
      const nodeFragments = [];

      for (let i = 0; i < segCount && idx + 4 < len; i++) {
        const ax = arr[idx++]; const ay = arr[idx++]; const bx = arr[idx++]; const by = arr[idx++]; const segId = arr[idx++];
        const hue = (segId * 137.508) % 360;
        const color = `hsl(${hue}, 70%, 50%)`;

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', ax); line.setAttribute('y1', ay);
        line.setAttribute('x2', bx); line.setAttribute('y2', by);
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', 3);
        line.setAttribute('stroke-linecap', 'round');
        segFragments.push(line);

        // Arrow at midpoint pointing A->B
        const midX = (ax + bx) * 0.5;
        const midY = (ay + by) * 0.5;
        const angle = Math.atan2(by - ay, bx - ax);
        const size = 6;
        const leftAngle = angle + Math.PI * 0.85;
        const rightAngle = angle - Math.PI * 0.85;
        const p1x = midX;
        const p1y = midY;
        const p2x = midX + Math.cos(leftAngle) * size;
        const p2y = midY + Math.sin(leftAngle) * size;
        const p3x = midX + Math.cos(rightAngle) * size;
        const p3y = midY + Math.sin(rightAngle) * size;

        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        arrow.setAttribute('points', `${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`);
        arrow.setAttribute('fill', color);
        arrow.setAttribute('opacity', '0.8');
        segFragments.push(arrow);

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', midX);
        label.setAttribute('y', midY - 4);
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('dominant-baseline', 'central');
        label.setAttribute('fill', 'white');
        label.setAttribute('stroke', 'black');
        label.setAttribute('stroke-width', '0.75');
        label.setAttribute('font-size', '10');
        label.textContent = Math.floor(segId).toString();
        segFragments.push(label);
      }

      if (idx < len) {
        const nodeCount = Math.floor(arr[idx++] || 0);
        for (let i = 0; i < nodeCount && idx + 2 < len; i++) {
          const nx = arr[idx++]; const ny = arr[idx++]; const nodeId = arr[idx++];
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', nx);
          circle.setAttribute('cy', ny);
          circle.setAttribute('r', 3);
          circle.setAttribute('fill', 'black');
          nodeFragments.push(circle);

          const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          label.setAttribute('x', nx + 5);
          label.setAttribute('y', ny - 5);
          label.setAttribute('fill', 'black');
          label.setAttribute('font-size', '10');
          label.setAttribute('stroke', 'white');
          label.setAttribute('stroke-width', '0.5');
          label.textContent = `#${Math.floor(nodeId)}`;
          nodeFragments.push(label);
        }
      }

      graphDebugLayer.replaceChildren(...segFragments, ...nodeFragments);
    }

    /**
     * Allocates from the end of memory buffer
     * @param {string} str - string to encode
     * @returns {{ptr: number, len: number}} memory pointer and length
     */
    function encodeStringToWasm(str) {
      const buffer = new TextEncoder().encode(str);
      const ptr = wasm.memory.buffer.byteLength - 256;
      const view = new Uint8Array(wasm.memory.buffer, ptr, buffer.length);
      view.set(buffer);
      return { ptr, len: buffer.length };
    }

    canvas.addEventListener('pointerdown', (evt) => {
      evt.preventDefault();
      if (!wasm) return;
      canvas.setPointerCapture(evt.pointerId);
      const point = toSvgPoint(evt);

      if (fillMode) {
        fillMode = false;
        fillBtn.classList.remove('active');
        // Set the color before filling
        const colorHex = fillColor.value;
        const colorBytes = new TextEncoder().encode(colorHex);
        const colorPtr = wasm.memory.buffer.byteLength - 256;
        const colorView = new Uint8Array(wasm.memory.buffer, colorPtr, colorBytes.length);
        colorView.set(colorBytes);
        wasm.editor_set_fill_color(colorPtr, colorBytes.length);
        wasm.editor_fill_debug_at(point.x, point.y);
        renderFillTrace();
        renderFillDebug();
        renderFromWasm();
      } else {
        startPoint = point;
        dragging = true;
        if (showLines) {
          preview.classList.add('active');
        }
        preview.setAttribute('x1', startPoint.x);
        preview.setAttribute('y1', startPoint.y);
        preview.setAttribute('x2', startPoint.x);
        preview.setAttribute('y2', startPoint.y);
      }
    });

    /**
     * Handle pointer move for line preview and debug overlay
     * @param {PointerEvent} evt
     */
    canvas.addEventListener('pointermove', (evt) => {
      const pos = toSvgPoint(evt);
      
      // Update debug overlay anytime if enabled (not just during drawing)
      if (debugMode && wasm) {
        wasm.editor_nearest(pos.x, pos.y);
        updateDebugOverlay(pos.x, pos.y);
      }
      
      // Only update preview if actively drawing
      if (!dragging) return;
      preview.setAttribute('x2', pos.x);
      preview.setAttribute('y2', pos.y);
    });

    /**
     * Update debug overlay with nearest point and line
     * @param {number} px - cursor x
     * @param {number} py - cursor y
     */
    function updateDebugOverlay(px, py) {
      const debugLen = wasm.editor_debug_len_f32();
      const debugPtr = wasm.editor_debug_ptr_f32();

      if (debugLen <= 0) {
        debugNearestLine.classList.remove('active');
        debugNearestPoint.classList.remove('active');
        debugRay.classList.remove('active');
        return;
      }

      const debugArr = new Float32Array(wasm.memory.buffer, debugPtr, debugLen);
      const hitFlag = debugArr[0];

      if (hitFlag < 0.5) {
        debugNearestLine.classList.remove('active');
        debugNearestPoint.classList.remove('active');
        debugRay.classList.remove('active');
        return;
      }

      const seg_x1 = debugArr[1];
      const seg_y1 = debugArr[2];
      const seg_x2 = debugArr[3];
      const seg_y2 = debugArr[4];
      const qx = debugArr[5];
      const qy = debugArr[6];

      // Update nearest line segment
      debugNearestLine.setAttribute('x1', seg_x1);
      debugNearestLine.setAttribute('y1', seg_y1);
      debugNearestLine.setAttribute('x2', seg_x2);
      debugNearestLine.setAttribute('y2', seg_y2);
      debugNearestLine.classList.add('active');

      // Update nearest point
      debugNearestPoint.setAttribute('cx', qx);
      debugNearestPoint.setAttribute('cy', qy);
      debugNearestPoint.classList.add('active');

      // Update ray from cursor to nearest point
      debugRay.setAttribute('x1', px);
      debugRay.setAttribute('y1', py);
      debugRay.setAttribute('x2', qx);
      debugRay.setAttribute('y2', qy);
      debugRay.classList.add('active');
    }

    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointercancel', () => { dragging = false; preview.classList.remove('active'); });
    canvas.addEventListener('pointerleave', () => {
      dragging = false;
      preview.classList.remove('active');
      if (debugMode) {
        debugNearestLine.classList.remove('active');
        debugNearestPoint.classList.remove('active');
        debugRay.classList.remove('active');
      }
    });

    /**
     * Handle end of drag - add line to editor
     * @param {PointerEvent} evt
     */
    function endDrag(evt) {
      if (!dragging || !wasm) return;
      dragging = false;
      preview.classList.remove('active');
      const end = toSvgPoint(evt);
      console.log(`Line added: (${startPoint.x.toFixed(1)},${startPoint.y.toFixed(1)}) -> (${end.x.toFixed(1)},${end.y.toFixed(1)})`);
      wasm.editor_add_line(startPoint.x, startPoint.y, end.x, end.y);
      console.log('Total lines now:', wasm.editor_line_count());
      renderFromWasm();
    }

    fillBtn.addEventListener('click', () => {
      fillMode = !fillMode;
      fillBtn.classList.toggle('active');
      if (!fillMode) canvas.style.cursor = 'default';
      else canvas.style.cursor = 'crosshair';
    });

    fillColor.addEventListener('change', () => {
      if (wasm) {
        const colorHex = fillColor.value;
        const colorBytes = new TextEncoder().encode(colorHex);
        const colorPtr = wasm.memory.buffer.byteLength - 256;
        const colorView = new Uint8Array(wasm.memory.buffer, colorPtr, colorBytes.length);
        colorView.set(colorBytes);
        wasm.editor_set_fill_color(colorPtr, colorBytes.length);
      }
    });

    debugBtn.addEventListener('click', () => {
      debugMode = !debugMode;
      debugBtn.classList.toggle('active');
      wasm.editor_set_debug(debugMode ? 1 : 0);
      if (!debugMode) {
        debugLayer.style.display = 'none';
        // Clear fill debug visuals when debug mode is disabled
        fillTraceLayer.replaceChildren();
        fillDebugLayer.replaceChildren();
      } else {
        debugLayer.style.display = 'block';
        updateDebugIntersections();
      }
    });

    graphDebugBtn.addEventListener('click', () => {
      graphDebugMode = !graphDebugMode;
      graphDebugBtn.classList.toggle('active');
      if (graphDebugMode) {
        renderGraphDebug();
      } else {
        graphDebugLayer.replaceChildren();
      }
    });

    toggleLinesBtn.addEventListener('click', () => {
      showLines = !showLines;
      toggleLinesBtn.textContent = showLines ? 'Hide Lines' : 'Show Lines';
      console.log('[UI] showLines =', showLines);
      renderFromWasm();
    });

    undoBtn.addEventListener('click', () => {
      if (wasm) {
        wasm.editor_undo();
        renderFromWasm();
      }
    });

    clearBtn.addEventListener('click', () => {
      if (wasm) {
        wasm.editor_clear();
        renderFromWasm();
        renderFillTrace();
      }
    });

    /**
     * Load and instantiate WASM module
     * @returns {Promise<{instance: WebAssembly.Instance}>}
     */
    async function loadWasm() {
      const response = await fetch('rust-svg-editor.wasm');
      if (WebAssembly.instantiateStreaming) {
        try {
          return await WebAssembly.instantiateStreaming(response);
        } catch (_) {
          // fallback below
        }
      }
      const buffer = await response.arrayBuffer();
      return WebAssembly.instantiate(buffer);
    }

    (async () => {
      const { instance } = await loadWasm();
      wasm = instance.exports;
      wasm.editor_init();
      
      // Initialize fill color
      const colorHex = fillColor.value;
      const colorBytes = new TextEncoder().encode(colorHex);
      const colorPtr = wasm.memory.buffer.byteLength - 256;
      const colorView = new Uint8Array(wasm.memory.buffer, colorPtr, colorBytes.length);
      colorView.set(colorBytes);
      wasm.editor_set_fill_color(colorPtr, colorBytes.length);
      
      renderFromWasm();
    })();
  </script>
</body>
</html>
