<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rust WASM SVG Line Editor</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    :root {
      --ink: #0f172a;
      --paper: #f5f6fb;
      --accent: #2dd4bf;
      --accent-dark: #0ea5e9;
    }
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: var(--paper);
      color: var(--ink);
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      gap: 10px;
      flex-wrap: wrap;
    }
    h1 { margin: 0; font-size: 24px; }
    button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover { background: var(--accent-dark); }
    button.active {
      background: #ef4444;
    }
    input[type="color"] {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    svg {
      border: 1px solid #ddd;
      background: white;
      border-radius: 4px;
      display: block;
      margin-bottom: 20px;
      touch-action: none;
    }
    #lines line {
      stroke: var(--ink);
      stroke-width: 2;
      stroke-linecap: round;
    }
    #preview {
      stroke: var(--accent);
      stroke-width: 2;
      stroke-dasharray: 5,5;
      opacity: 0.6;
      display: none;
    }
    #preview.active { display: block; }
    #fills polygon {
      stroke: none;
      opacity: 0.7;
    }
    #debugLayer {
      pointer-events: none;
    }
    #debugNearestLine {
      stroke: #0ea5e9;
      stroke-width: 3;
      stroke-dasharray: 3,3;
      display: none;
    }
    #debugNearestLine.active { display: block; }
    #debugNearestPoint {
      fill: #0ea5e9;
      r: 4;
      display: none;
    }
    #debugNearestPoint.active { display: block; }
    #debugRay {
      stroke: #0ea5e9;
      stroke-width: 1;
      opacity: 0.5;
      display: none;
    }
    #debugRay.active { display: block; }
    #debugIntersections circle {
      fill: #ef4444;
      r: 3;
    }
    #status {
      font-size: 12px;
      color: #666;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Rustroke</h1>
      <div style="display: flex; gap: 10px;">
        <button id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
        <button id="clearBtn" title="Clear">Clear</button>
        <button id="fillBtn" title="Fill Region">Fill</button>
        <input id="fillColor" type="color" value="#747474" title="Fill color">
        <button id="debugBtn" title="Toggle Debug Mode">Debug</button>
      </div>
    </header>

    <svg id="canvas" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
      <defs>
        <style>
          text { font-size: 12px; fill: #999; }
        </style>
      </defs>
      <g id="fills"></g>
      <g id="lines"></g>
      <line id="preview"></line>
      <g id="debugLayer">
        <line id="debugNearestLine"></line>
        <circle id="debugNearestPoint"></circle>
        <line id="debugRay"></line>
        <g id="debugIntersections"></g>
      </g>
    </svg>

    <div id="status">Lines: 0</div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const linesGroup = document.getElementById('lines');
    const fillsGroup = document.getElementById('fills');
    const preview = document.getElementById('preview');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const fillBtn = document.getElementById('fillBtn');
    const fillColor = document.getElementById('fillColor');
    const debugBtn = document.getElementById('debugBtn');
    const statusEl = document.getElementById('status');
    const debugLayer = document.getElementById('debugLayer');
    const debugNearestLine = document.getElementById('debugNearestLine');
    const debugNearestPoint = document.getElementById('debugNearestPoint');
    const debugRay = document.getElementById('debugRay');
    const debugIntersectionsGroup = document.getElementById('debugIntersections');
    const viewBox = canvas.viewBox.baseVal;

    let wasm = null;
    let dragging = false;
    let fillMode = false;
    let debugMode = false;
    /** @type {{x: number, y: number}} */
    let startPoint = { x: 0, y: 0 };

    /**
     * Convert pointer event coordinates to SVG viewBox coordinates
     * @param {PointerEvent} evt - pointer event
     * @returns {{x: number, y: number}} point in SVG coordinates
     */
    function toSvgPoint(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = ((evt.clientX - rect.left) / rect.width) * viewBox.width + viewBox.x;
      const y = ((evt.clientY - rect.top) / rect.height) * viewBox.height + viewBox.y;
      return { x, y };
    }

    /**
     * Render lines and fills from WASM memory
     */
    function renderFromWasm() {
      if (!wasm) return;
      const len = wasm.editor_export_len_f32();
      const ptr = wasm.editor_export_ptr_f32();
      if (!ptr || len === 0) {
        linesGroup.replaceChildren();
        statusEl.textContent = 'Lines: 0';
      } else {
        const arr = new Float32Array(wasm.memory.buffer, ptr, len);
        const fragments = [];
        for (let i = 0; i < arr.length; i += 4) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', arr[i + 0]);
          line.setAttribute('y1', arr[i + 1]);
          line.setAttribute('x2', arr[i + 2]);
          line.setAttribute('y2', arr[i + 3]);
          fragments.push(line);
        }
        linesGroup.replaceChildren(...fragments);
        statusEl.textContent = `Lines: ${wasm.editor_line_count()}`;
      }

      // Render fills
      const fillsLen = wasm.editor_export_fills_len();
      const fillsPtr = wasm.editor_export_fills_ptr();
      if (fillsPtr && fillsLen > 0) {
        const fillsArr = new Float32Array(wasm.memory.buffer, fillsPtr, fillsLen);
        const fillFragments = [];
        let i = 0;
        while (i < fillsArr.length) {
          const pointCount = fillsArr[i];
          const r = Math.round(fillsArr[i + 1] * 255);
          const g = Math.round(fillsArr[i + 2] * 255);
          const b = Math.round(fillsArr[i + 3] * 255);
          const a = fillsArr[i + 4];
          i += 5;

          const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          let points = '';
          for (let j = 0; j < pointCount && i < fillsArr.length; j++) {
            const x = fillsArr[i];
            const y = fillsArr[i + 1];
            points += `${x},${y} `;
            i += 2;
          }
          polygon.setAttribute('points', points);
          polygon.setAttribute('fill', `rgba(${r},${g},${b},${a})`);
          fillFragments.push(polygon);
        }
        fillsGroup.replaceChildren(...fillFragments);
      } else {
        fillsGroup.replaceChildren();
      }

      // Update intersection dots if debug is on
      if (debugMode) {
        updateDebugIntersections();
      }
    }

    /**
     * Update debug intersection dots from cached intersections in Rust
     */
    function updateDebugIntersections() {
      const intLen = wasm.editor_intersections_len_f32();
      const intPtr = wasm.editor_intersections_ptr_f32();
      debugIntersectionsGroup.replaceChildren();

      if (intLen <= 0) return;

      const intArr = new Float32Array(wasm.memory.buffer, intPtr, intLen);
      const count = intArr[0];

      for (let i = 0; i < count; i++) {
        const x = intArr[1 + i * 2];
        const y = intArr[1 + i * 2 + 1];
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', 3);
        circle.setAttribute('fill', '#ef4444');
        debugIntersectionsGroup.appendChild(circle);
      }
    }

    /**
     * Encode string to WASM memory and return pointer/length
     * Allocates from the end of memory buffer
     * @param {string} str - string to encode
     * @returns {{ptr: number, len: number}} memory pointer and length
     */
    function encodeStringToWasm(str) {
      const buffer = new TextEncoder().encode(str);
      const ptr = wasm.memory.buffer.byteLength - 256;
      const view = new Uint8Array(wasm.memory.buffer, ptr, buffer.length);
      view.set(buffer);
      return { ptr, len: buffer.length };
    }

    canvas.addEventListener('pointerdown', (evt) => {
      evt.preventDefault();
      if (!wasm) return;
      canvas.setPointerCapture(evt.pointerId);
      const point = toSvgPoint(evt);

      if (fillMode) {
        fillMode = false;
        fillBtn.classList.remove('active');
        const color = fillColor.value;
        const { ptr, len } = encodeStringToWasm(color);
        wasm.editor_fill(point.x, point.y, ptr, len);
        renderFromWasm();
      } else {
        startPoint = point;
        dragging = true;
        preview.classList.add('active');
        preview.setAttribute('x1', startPoint.x);
        preview.setAttribute('y1', startPoint.y);
        preview.setAttribute('x2', startPoint.x);
        preview.setAttribute('y2', startPoint.y);
      }
    });

    /**
     * Handle pointer move for line preview and debug overlay
     * @param {PointerEvent} evt
     */
    canvas.addEventListener('pointermove', (evt) => {
      const pos = toSvgPoint(evt);
      
      // Update debug overlay anytime if enabled (not just during drawing)
      if (debugMode && wasm) {
        wasm.editor_nearest(pos.x, pos.y);
        updateDebugOverlay(pos.x, pos.y);
      }
      
      // Only update preview if actively drawing
      if (!dragging) return;
      preview.setAttribute('x2', pos.x);
      preview.setAttribute('y2', pos.y);
    });

    /**
     * Update debug overlay with nearest point and line
     * @param {number} px - cursor x
     * @param {number} py - cursor y
     */
    function updateDebugOverlay(px, py) {
      const debugLen = wasm.editor_debug_len_f32();
      const debugPtr = wasm.editor_debug_ptr_f32();

      if (debugLen <= 0) {
        debugNearestLine.classList.remove('active');
        debugNearestPoint.classList.remove('active');
        debugRay.classList.remove('active');
        return;
      }

      const debugArr = new Float32Array(wasm.memory.buffer, debugPtr, debugLen);
      const hitFlag = debugArr[0];

      if (hitFlag < 0.5) {
        debugNearestLine.classList.remove('active');
        debugNearestPoint.classList.remove('active');
        debugRay.classList.remove('active');
        return;
      }

      const seg_x1 = debugArr[1];
      const seg_y1 = debugArr[2];
      const seg_x2 = debugArr[3];
      const seg_y2 = debugArr[4];
      const qx = debugArr[5];
      const qy = debugArr[6];

      // Update nearest line segment
      debugNearestLine.setAttribute('x1', seg_x1);
      debugNearestLine.setAttribute('y1', seg_y1);
      debugNearestLine.setAttribute('x2', seg_x2);
      debugNearestLine.setAttribute('y2', seg_y2);
      debugNearestLine.classList.add('active');

      // Update nearest point
      debugNearestPoint.setAttribute('cx', qx);
      debugNearestPoint.setAttribute('cy', qy);
      debugNearestPoint.classList.add('active');

      // Update ray from cursor to nearest point
      debugRay.setAttribute('x1', px);
      debugRay.setAttribute('y1', py);
      debugRay.setAttribute('x2', qx);
      debugRay.setAttribute('y2', qy);
      debugRay.classList.add('active');
    }

    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointercancel', () => { dragging = false; preview.classList.remove('active'); });
    canvas.addEventListener('pointerleave', () => {
      dragging = false;
      preview.classList.remove('active');
      if (debugMode) {
        debugNearestLine.classList.remove('active');
        debugNearestPoint.classList.remove('active');
        debugRay.classList.remove('active');
      }
    });

    /**
     * Handle end of drag - add line to editor
     * @param {PointerEvent} evt
     */
    function endDrag(evt) {
      if (!dragging || !wasm) return;
      dragging = false;
      preview.classList.remove('active');
      const end = toSvgPoint(evt);
      console.log(`Line added: (${startPoint.x.toFixed(1)},${startPoint.y.toFixed(1)}) -> (${end.x.toFixed(1)},${end.y.toFixed(1)})`);
      wasm.editor_add_line(startPoint.x, startPoint.y, end.x, end.y);
      console.log('Total lines now:', wasm.editor_line_count());
      renderFromWasm();
    }

    fillBtn.addEventListener('click', () => {
      fillMode = !fillMode;
      fillBtn.classList.toggle('active');
      if (!fillMode) canvas.style.cursor = 'default';
      else canvas.style.cursor = 'crosshair';
    });

    debugBtn.addEventListener('click', () => {
      debugMode = !debugMode;
      debugBtn.classList.toggle('active');
      wasm.editor_set_debug(debugMode ? 1 : 0);
      if (!debugMode) {
        debugLayer.style.display = 'none';
      } else {
        debugLayer.style.display = 'block';
        updateDebugIntersections();
      }
    });

    undoBtn.addEventListener('click', () => {
      if (wasm) {
        wasm.editor_undo();
        renderFromWasm();
      }
    });

    clearBtn.addEventListener('click', () => {
      if (wasm) {
        wasm.editor_clear();
        renderFromWasm();
      }
    });

    /**
     * Load and instantiate WASM module
     * @returns {Promise<{instance: WebAssembly.Instance}>}
     */
    async function loadWasm() {
      const response = await fetch('rust-svg-editor.wasm');
      if (WebAssembly.instantiateStreaming) {
        try {
          return await WebAssembly.instantiateStreaming(response);
        } catch (_) {
          // fallback below
        }
      }
      const buffer = await response.arrayBuffer();
      return WebAssembly.instantiate(buffer);
    }

    (async () => {
      const { instance } = await loadWasm();
      wasm = instance.exports;
      wasm.editor_init();
      renderFromWasm();
    })();
  </script>
</body>
</html>
